diff -r d244a10db46e GAS/gas_setup.f
--- a/GAS/gas_setup.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/GAS/gas_setup.f	Thu Feb 15 15:27:16 2018 -0600
@@ -13,9 +13,10 @@
 * Initialize the gas grid, the part that is constant with time and
 * temperature. The part that changes is done in gas_grid_update.
 ************************************************************************
-      integer :: l,i
+      integer :: l
+      integer :: i
       real*8 :: mass0fr(-2*gas_nchain:gas_nelem,gas_ncell)
-c
+
 c-- agnostic mass setup
       gas_mass = str_massdd
 c
@@ -48,7 +49,13 @@
 c
 c-- adopt partial masses from input file
       mass0fr = 0d0
-      if(.not.in_noreadstruct) then
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+c     old line
+c     if(.not.in_noreadstruct) then
+c     new line
+      if(.not.in_noreadstruct.or.in_test_problem.ne.0) then
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        if(.not.allocated(str_massfrdd)) stop 'input.str data not avail'
        do l=1,str_nabund
         i = str_iabund(l)
@@ -115,6 +122,7 @@
 c
 c-- partial mass
        gas_natom1fr(:,i) = mass0fr(:,i)*gas_mass(i)
+
 c
 c-- take out radioactive part
        gas_natom1fr(28,i) = gas_natom1fr(28,i) -
@@ -201,12 +209,11 @@
 c
 c-- total natom
        gas_natom(i) = sum(gas_natom1fr(1:,i))
-c
 c-- convert natoms to natom fractions
        gas_natom1fr(:,i) = gas_natom1fr(:,i)/gas_natom(i)
        gas_natom0fr(:,i,:) = gas_natom0fr(:,i,:)/gas_natom(i)
 c
       enddo !i
-c!}}}
+c !}}}
       end subroutine massfr2natomfr
 c vim: fdm=marker
diff -r d244a10db46e GAS/gas_update.f
--- a/GAS/gas_update.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/GAS/gas_update.f	Thu Feb 15 15:27:16 2018 -0600
@@ -12,6 +12,10 @@
       use gasmod
       use inputparmod
       use timingmod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      use hydromod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       implicit none
       integer,intent(in) :: it
 ************************************************************************
@@ -36,7 +40,6 @@
 !     real*8 :: hlparr(grd_nx),hlparrdd(gas_ncell)
 c-- timing
       real*8 :: t0,t1
-c
 c-- begin
       t0 = t_time()
 c
@@ -66,15 +69,27 @@
 c-- current time step
       if(grd_isvelocity.and.in_srctype=='none') then
 c-- beginning of time step
-       call update_natomfr(tsp_t)
+       if( grd_hydro_on ) then
+         call update_natomfr(0d0)
+       else
+         call update_natomfr(tsp_t)
+       endif
        natom1fr = gas_natom1fr
 c-- end of time step
-       call update_natomfr(tsp_t + tsp_dt)
+       if( grd_hydro_on ) then
+         call update_natomfr(tsp_dt)
+       else
+         call update_natomfr(tsp_t+tsp_dt)
+       endif
        natom2fr = gas_natom1fr
 c
 c-- update the abundances for the center time
        !call update_natomfr(tsp_tcenter)
-       call update_natomfr(tsp_t)
+       if( grd_hydro_on ) then
+         call update_natomfr(0d0)
+       else
+         call update_natomfr(tsp_t)
+       endif
 c-- sanity check
        if(any(gas_natom1fr<0d0)) stop 'gas_update: natom1fr<0'
 !c-- print change in electron fraction
@@ -109,6 +124,8 @@
 !}}}
 c
 c
+
+
 c-- update volume
 c========================================
       i = 0
@@ -117,46 +134,67 @@
        gas_vol(i) = grd_vol(l)
       enddo !l
 c
-c
+
 c-- update density, start temperature derivative
 c===============================================
-      gas_rho = gas_mass/gas_vol
+
+        gas_rho = gas_mass/gas_vol
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      if( grd_hydro_on .and. it_gt_0 ) then
+        if( lfirst ) then
+          call eos_update(.false.)
+        endif
+        call hydro_update(tsp_t, tsp_t + tsp_dt)
+        gas_mass = gas_rho * gas_vol
+      endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c-- temperature
       gas_ur = pc_acoef*gas_temp**4
 c
 c-- sanity check temperatures
+
       if(any(gas_temp/=gas_temp)) stop 'gas_temp NaN'
       if(any(gas_temp<=0d0)) stop 'gas_temp<=0'
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      if( in_radiation_on ) then
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c
 c
 c
 c-- compute the starting tempurature derivative in the fleck factor
-      if(lfirst .or. in_opacanaltype/='none') then
+        if(lfirst .or. in_opacanaltype/='none') then
 c-- temporarily change!{{{
-       gas_temp = dtempfrac*gas_temp
-       if(in_opacanaltype=='none') then
-        if(.not.in_noeos) call eos_update(.false.)
-       endif
+         gas_temp = dtempfrac*gas_temp
+         if(in_opacanaltype=='none') then
+          if(.not.in_noeos) call eos_update(.false.)
+         endif
 c
-       if(in_opacanaltype/='none') then
-        call analytic_opacity
-       else
-        call physical_opacity
-       endif
-       call opacity_planckmean
+         if(in_opacanaltype/='none') then
+          call analytic_opacity
+         else
+          call physical_opacity
+         endif
+         call opacity_planckmean
 c
 c-- save
-       if(.not.allocated(tempalt)) then
-        allocate(tempalt(gas_ncell))
-        allocate(capgreyalt(gas_ncell))
-       endif
-       tempalt = gas_temp
-       capgreyalt = gas_capgrey/gas_rho !per gram
+         if(.not.allocated(tempalt)) then
+          allocate(tempalt(gas_ncell))
+          allocate(capgreyalt(gas_ncell))
+         endif
+         tempalt = gas_temp
+         capgreyalt = gas_capgrey/gas_rho !per gram
 c
 c-- change back
-       gas_temp = gas_temp/dtempfrac
+         gas_temp = gas_temp/dtempfrac
 !}}}
-      endif
+        endif
+
 c
 c
 c
@@ -165,6 +203,11 @@
       do_output = (in_io_pdensdump=='each' .or.
      &  (in_io_pdensdump=='one' .and. tsp_it==1))
       if(.not.in_noeos) call eos_update(do_output)
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
       if(in_gas_cvcoef>0d0) then
 c-- calculate power law heat capacity
@@ -185,81 +228,95 @@
        tot_emat = sum(gas_bcoef*gas_temp*gas_vol)
        tot_eext = tot_eext + tot_emat  !was initialized either in totalsmod or in totals_startup
       endif      
+
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      if( in_radiation_on ) then
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c
 c
 c
 c-- calculate opacities
 c======================
 c-- gamma opacity
-      gas_capgam = in_opcapgam*gas_ye*gas_rho
+        gas_capgam = in_opcapgam*gas_ye*gas_rho
 c
 c
 c-- simple analytical group/grey opacities: Planck and Rosseland 
-      if(in_opacanaltype/='none') then
-       call analytic_opacity
-      else
+        if(in_opacanaltype/='none') then
+         call analytic_opacity
+        else
 c-- calculate physical opacities
 c-- test existence of input.opac file
-       inquire(file='input.opac',exist=lexist)
-       if(.not.lexist) then
+         inquire(file='input.opac',exist=lexist)
+         if(.not.lexist) then
 c-- calculate opacities
-        call physical_opacity
-       else
+          call physical_opacity
+         else
 c-- read in opacities
-        open(4,file='input.opac',status='old',iostat=istat)!{{{
-        if(istat/=0) stop 'read_opac: no file: input.opac'
+          open(4,file='input.opac',status='old',iostat=istat)!{{{
+          if(istat/=0) stop 'read_opac: no file: input.opac'
 c-- read header
-        read(4,*,iostat=istat)
-        if(istat/=0) stop 'read_opac: file empty: input.opac'
+          read(4,*,iostat=istat)
+          if(istat/=0) stop 'read_opac: file empty: input.opac'
 c-- read each cell individually
-        do j=1,tsp_it
+          do j=1,tsp_it
 c-- skip delimiter
          read(4,*,iostat=istat)
-         if(istat/=0) stop 'read_opac: delimiter error: input.opac'
+           if(istat/=0) stop 'read_opac: delimiter error: input.opac'
 c-- read data
-         do i=1,gas_ncell
-          read(4,*,iostat=istat) help,gas_sig(i),gas_cap(:,i)
-          if(istat/=0) stop 'read_opac: body error: input.opac'
-         enddo !i
-        enddo !j
-        close(4)
-        write(6,*) 'read_opac: read successfully'
+           do i=1,gas_ncell
+            read(4,*,iostat=istat) help,gas_sig(i),gas_cap(:,i)
+            if(istat/=0) stop 'read_opac: body error: input.opac'
+           enddo !i
+          enddo !j
+          close(4)
+          write(6,*) 'read_opac: read successfully'
 !}}}
-       endif
-      endif
-      call opacity_planckmean
+         endif
+        endif
+        call opacity_planckmean
 c
 c
 c-- write out opacities
 c----------------------
-      if(trim(in_io_opacdump)=='off') then !{{{
-c-- donothing
-      else
-       open(4,file='output.opac',status='unknown',position='append')
-      endif !off
+        if(trim(in_io_opacdump)=='off') then !{{{
+c-- don othing
+       else
+         open(4,file='output.opac',status='unknown',position='append')
+        endif !off
 c
 c-- write opacity grid
-      inquire(4,opened=do_output)
-      if(do_output) then
+        inquire(4,opened=do_output)
+        if(do_output) then
 c-- header
-       if(tsp_it==1) write(4,'("#",3i8)') gas_ncell,tsp_nt
-       write(4,'("#",3i8)') tsp_it
+         if(tsp_it==1) write(4,'("#",3i8)') gas_ncell,tsp_nt
+         write(4,'("#",3i8)') tsp_it
 c-- body
-       do i=1,gas_ncell
-        write(4,'(1p,9999e12.4)') gas_temp(i),gas_sig(i),gas_cap(:,i)
-       enddo
+         do i=1,gas_ncell
+          write(4,'(1p,9999e12.4)') gas_temp(i),gas_sig(i),gas_cap(:,i)
+         enddo
 c-- close file
-       close(4)
-      endif !do_output !}}}
+        close(4)
+        endif !do_output !}}}
 c
 c
 c-- Calculating Fleck factor, leakage opacities
-      call fleck_factor(tempalt,capgreyalt)
+        call fleck_factor(tempalt,capgreyalt)
 c
 c
 c-- save previous values for gentile-fleck factor calculation in next iter
-      tempalt = gas_temp
-      capgreyalt = gas_capgrey/gas_rho
+        tempalt = gas_temp
+        capgreyalt = gas_capgrey/gas_rho
+
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c
       lfirst = .false.
 c
@@ -279,6 +336,8 @@
 c     ----------------------------!{{{
       use nucdatamod
       use gasmod
+      use gridmod
+      use timestepmod
       implicit none
       real*8,intent(in) :: t
 ************************************************************************
@@ -291,7 +350,7 @@
       real*8 :: dye(gas_ncell) !delta natom*ye
 c
 c-- save norm for conservation check
-      natom = sum(gas_natom1fr(22:28,:),dim=1)
+      natom = sum(gas_natom1fr(1:,:),dim=1)
 c
 c-- zero
       gas_natom1fr(22:28,:) = 0d0
@@ -327,6 +386,7 @@
       dye = dye - x(:,1)*(25d0/52)
 c-- update
       call nucdecay3(gas_ncell,t,nuc_thl_fe52,nuc_thl_mn52,x)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c-- current radioactive natom
       gas_natom1fr(gas_ife52,:) = x(:,2)
       gas_natom1fr(gas_imn52,:) = x(:,1)
@@ -367,9 +427,11 @@
 c
 c-- natom conservation check
       do i=1,gas_ncell
-       help = sum(gas_natom1fr(22:28,i))
-       if(abs(help-natom(i))>1d-14*natom(i)) stop
-     &   'update_natomfr: natom not conserved'
+       help = sum(gas_natom1fr(1:,i))
+       if(abs(help-natom(i))>1d-14*natom(i)) then
+       write(*,*) help, natom(i),i
+       stop 'update_natomfr: natom not conserved'
+       endif
       enddo
 c
 c-- calculate Ye
diff -r d244a10db46e GRID/grid_setup.f
--- a/GRID/grid_setup.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/GRID/grid_setup.f	Thu Feb 15 15:27:16 2018 -0600
@@ -6,6 +6,10 @@
       use inputparmod
       use inputstrmod
       use physconstmod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      use hydromod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       implicit none
 ************************************************************************
 * Setup the grid on the computational domain
@@ -60,6 +64,7 @@
 c-- maximum grid velocity
       select case(grd_igeom)
       case(1,11)
+       write(*,*) grd_nx
        grd_rout = grd_xarr(grd_nx+1)
 c-- cylindrical
       case(2)
@@ -122,6 +127,47 @@
 c
 c-- zero amplification-factor energy to begin with
       grd_eamp = 0d0
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c       HYDRO LSU
+          if( grd_isvelocity ) then
+            if(in_test_problem .eq. 0) then
+                do i = 1, grd_nx
+                do j = 1, grd_ny
+                do k = 1, grd_nz
+                  l = grd_icell(i,j,k)
+                  grd_vx(l) = (grd_xarr(i+1) + grd_xarr(i))*0.5d0
+                  if( (grd_igeom .eq. 1) .or. (grd_igeom .eq. 11) ) then
+                    grd_vy(l) = 0d0
+                  else
+                    grd_vy(l) = (grd_yarr(j+1) + grd_yarr(j))*0.5d0
+                  endif
+                  if( grd_igeom .eq. 3 ) then
+                    grd_vz(l) = (grd_zarr(k+1) + grd_zarr(k))*0.5d0
+                  else
+                    grd_vz(l) = 0d0
+                  endif
+                enddo
+                enddo
+                enddo
+            else
+                do i = 1, grd_nx
+                do j = 1, grd_ny
+                do k = 1, grd_nz
+                  l = grd_icell(i,j,k)
+                  grd_vx(l) = str_vx(i,j,k)
+                  grd_vy(l) = str_vy(i,j,k)
+                  grd_vz(l) = str_vz(i,j,k)
+                enddo
+                enddo
+                enddo
+            end if
+          else
+            grd_vx = 0.0d0
+            grd_vy = 0.0d0
+            grd_vz = 0.0d0
+          endif
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
 c-- read preset temperature profiles
       inquire(file='input.temp',exist=lexist)
diff -r d244a10db46e GRID/grid_volume.f
--- a/GRID/grid_volume.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/GRID/grid_volume.f	Thu Feb 15 15:27:16 2018 -0600
@@ -23,6 +23,7 @@
        t = 1d0
       endif
 c
+
       select case(igeom)
       case(1,11)
        forall(i=1:grd_nx,j=1:grd_ny,k=1:grd_nz)
@@ -56,6 +57,7 @@
       do i=1,grd_nx
        l = grd_icell(i,j,k)
        grd_vol(l) = grd_vol(l) + vol(i,j,k) !multiple void cells are linked to the dummy cell
+
       enddo
       enddo
       enddo
diff -r d244a10db46e Makefile
--- a/Makefile	Mon Feb 20 16:32:09 2017 -0700
+++ b/Makefile	Thu Feb 15 15:27:16 2018 -0600
@@ -26,14 +26,14 @@
   miscmod.o ionsmod.o ffxsmod.o bfxsmod.o bbxsmod.o \
   inputparmod.o timestepmod.o groupmod.o gridmod.o gasmod.o inputstrmod.o \
   particlemod.o timingmod.o countersmod.o manufacmod.o fluxmod.o totalsmod.o \
-  transportmod.o sourcemod.o
-
+  transportmod.o sourcemod.o hydromod.o momentum.o
+  
 FILES := banner.o \
   particle_advance.o particle_advance_gamgrey.o fluxtally.o \
   dealloc_all.o read_bbxs_data.o tau_update.o
 
 LIBRARIES := TRANSPORT1/transport1.a TRANSPORT2/transport2.a TRANSPORT3/transport3.a \
-  SOURCE/source.a GAS/gas.a GRID/grid.a MISC/misc.a OUTPUT/output.a
+  SOURCE/source.a GAS/gas.a GRID/grid.a MISC/misc.a OUTPUT/output.a HYDRO/hydro.a
 SUBDIRS := $(dir $(LIBRARIES))
 SUBCLEAN = $(addsuffix .clean, $(SUBDIRS))
 
diff -r d244a10db46e SOURCE/sourceenergy_misc.f
--- a/SOURCE/sourceenergy_misc.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/SOURCE/sourceenergy_misc.f	Thu Feb 15 15:27:16 2018 -0600
@@ -25,6 +25,7 @@
 c
 c-- gamma deposition is energy source
       grd_emit = grd_emit + grd_tally(1,:)
+
       if(lmpi0) tot_sdeposgamma = sum(grd_tally(1,:))
 c-- clear eamp in the dummy cell
       if(grd_ivoid>0) grd_eamp(grd_ncell) = 0d0
diff -r d244a10db46e TRANSPORT1/diffusion11.f90
--- a/TRANSPORT1/diffusion11.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/TRANSPORT1/diffusion11.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -34,6 +34,10 @@
   real*8 :: r1, r2, thelp
   real*8 :: denom, denom2, denom3
   real*8 :: ddmct, tau, tcensus, pa
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  real*8 :: v0
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- lumped quantities -----------------------------------------
 
   real*8 :: emitlump, caplump
@@ -55,8 +59,14 @@
 !-- statement function
   integer :: l
   real*8 :: dx,dx3
+
   dx(l) = grd_xarr(l+1) - grd_xarr(l)
   dx3(l) = grd_xarr(l+1)**3 - grd_xarr(l)**3
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  real*8,pointer :: vx
+  vx => ptcl2%vx
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
   ix => ptcl2%ix
   ic => ptcl2%ic
@@ -67,6 +77,8 @@
   e0 => ptcl%e0
   wl => ptcl%wl
 
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+
   capgreyinv => cache%capgreyinv
   speclump => cache%speclump
   glumps => cache%glumps
@@ -210,6 +222,19 @@
              (mfphelp*thelp**3*dx3(ix))
      endif!}}}
   endif
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  if( grd_hydro_on ) then
+    v0 = grd_v(ix,iy,iz,1)
+    if( grd_isvelocity ) then
+      v0 = v0 - (grd_xarr(ix+1)+grd_xarr(ix)) / (tsp_t * 2d0)
+    endif
+    v0 = v0 / (pc_c * dx(ix))
+    opacleak(2) = opacleak(2) + max(v0,0d0)
+    opacleak(1) = opacleak(1) + min(v0,0d0)
+  endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !
 !-------------------------------------------------------------
 !
@@ -349,16 +374,32 @@
            call rnd_r(r2,rndstate)
            mu = -max(r1,r2)
 !-- doppler and aberration corrections
-           if(grd_isvelocity) then
-              mu = (mu+x*cinv)/(1.0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
+!              mu = (mu+x*cinv)/(1.0+x*mu*cinv)
 !-- velocity effects accounting
-              help = 1d0/(1.0-x*mu*cinv)
+!              help = 1d0/(1.0-x*mu*cinv)
+!              totevelo = totevelo+e*(1d0 - help)
+!
+!              e = e*help
+!              e0 = e0*help
+!              wl = wl*(1.0-x*mu*cinv)
+!           endif
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+              call hydro_velocity_at11(x, vx, ix, tsp_t)
+              mu = (mu+vx*cinv)/(1.0+vx*mu*cinv)
+!-- velocity effects accounting
+              help = 1d0/(1.0-vx*mu*cinv)
               totevelo = totevelo+e*(1d0 - help)
 !
               e = e*help
               e0 = e0*help
-              wl = wl*(1.0-x*mu*cinv)
+              wl = wl*(1.0-vx*mu*cinv)
            endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
 !
 !-- update particle
@@ -406,15 +447,30 @@
 !-- position
         x=grd_xarr(grd_nx+1)
 !-- changing from comoving frame to observer frame
-        if(grd_isvelocity) then
-           help = 1d0+mu*x*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
+!           help = 1d0+mu*x*cinv
+!-- velocity effects accounting
+!           totevelo = totevelo+e*(1d0 - help)
+!           wl = wl/help
+!           e = e*help
+!           e0 = e0*help
+!           mu = (mu+x*cinv)/(1d0+x*mu*cinv)
+!        endif
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+           call hydro_velocity_at11(x, vx, ix, tsp_t)
+           help = 1d0+mu*vx*cinv
 !-- velocity effects accounting
            totevelo = totevelo+e*(1d0 - help)
            wl = wl/help
            e = e*help
            e0 = e0*help
-           mu = (mu+x*cinv)/(1d0+x*mu*cinv)
+           mu = (mu+vx*cinv)/(1d0+vx*mu*cinv)
         endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- observer time correction
         ptcl%t=ptcl%t-mu*x*thelp*cinv
         return
@@ -470,16 +526,32 @@
            mu = max(r1,r2)
 !
 !-- doppler and aberration corrections
-           if(grd_isvelocity) then
-              mu = (mu+x*cinv)/(1.0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
+!              mu = (mu+x*cinv)/(1.0+x*mu*cinv)
 !-- velocity effects accounting
-              help = 1d0/(1.0-x*mu*cinv)
+!              help = 1d0/(1.0-x*mu*cinv)
+!              totevelo = totevelo+e*(1d0 - help)
+!
+!              e = e*help
+!              e0 = e0*help
+!              wl = wl*(1.0-x*mu*cinv)
+!           endif
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+              call hydro_velocity_at11(x, vx, ix, tsp_t)
+              mu = (mu+vx*cinv)/(1.0+vx*mu*cinv)
+!-- velocity effects accounting
+              help = 1d0/(1.0-vx*mu*cinv)
               totevelo = totevelo+e*(1d0 - help)
 !
               e = e*help
               e0 = e0*help
-              wl = wl*(1.0-x*mu*cinv)
+              wl = wl*(1.0-vx*mu*cinv)
            endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
 !
 !-- update particle
@@ -546,19 +618,37 @@
         x = min(x,grd_xarr(ix+1))
         x = max(x,grd_xarr(ix))
 !-- doppler and aberration corrections
-        if(grd_isvelocity) then
-           mu = (mu+x*cinv)/(1.0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
+!           mu = (mu+x*cinv)/(1.0+x*mu*cinv)
 !-- velocity effects accounting
-           help = 1d0/(1d0-x*mu*cinv)
+!           help = 1d0/(1d0-x*mu*cinv)
+!           totevelo = totevelo+e*(1d0 - help)
+!
+!           e = e*help
+!           e0 = e0*help
+!           wl = wl*(1.0-x*mu*cinv)
+!        endif
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+           call hydro_velocity_at11(x, vx, ix, tsp_t)
+           mu = (mu+vx*cinv)/(1.0+vx*mu*cinv)
+!-- velocity effects accounting
+           help = 1d0/(1d0-vx*mu*cinv)
            totevelo = totevelo+e*(1d0 - help)
 !
            e = e*help
            e0 = e0*help
-           wl = wl*(1.0-x*mu*cinv)
+           wl = wl*(1.0-vx*mu*cinv)
         endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      endif
 !}}}
   endif
 
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+
 end subroutine diffusion11
 ! vim: fdm=marker
diff -r d244a10db46e TRANSPORT1/transport11.f90
--- a/TRANSPORT1/transport11.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/TRANSPORT1/transport11.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -18,6 +18,10 @@
   type(rnd_t),intent(inout) :: rndstate
   real*8,intent(out) :: edep, eraddens, eamp
   real*8,intent(inout) :: totevelo
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!    LSU MODIFICATION
+  real*8, pointer :: vx
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   integer,intent(out) :: ierr
 !##################################################
 !This subroutine passes particle parameters as input and modifies
@@ -53,6 +57,10 @@
   ig => ptcl2%ig
   d => ptcl2%dist
   x => ptcl%x
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!    LSU MODIFICATION
+  vx => ptcl2%vx
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   mu => ptcl%mu
   e => ptcl%e
   e0 => ptcl%e0
@@ -66,14 +74,38 @@
   eamp = 0d0
 !
 !-- setting vel-grid helper variables  
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity) then
+!-- calculating initial transformation factors
+!     elabfact = 1d0 - mu*x*cinv
+!     thelp = tsp_t
+!  else
+!     elabfact = 1d0
+!     thelp = 1d0
+!  endif
+! New code
+
+
+  !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
   if(grd_isvelocity) then
-!-- calculating initial transformation factors
-     elabfact = 1d0 - mu*x*cinv
      thelp = tsp_t
   else
-     elabfact = 1d0
      thelp = 1d0
   endif
+  if(grd_isvelocity .or. grd_hydro_on) then
+     elabfact = 1d0 - mu*vx*cinv
+  else
+     elabfact = 1d0
+  endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !
 !-- inverting vel-grid factor
   thelpinv = 1d0/thelp
@@ -125,8 +157,20 @@
   endif
 !
 !-- Doppler shift distance
-  if(grd_isvelocity.and.ig<grp_ng) then
-     ddop = pc_c*(elabfact-wl*grp_wlinv(ig+1))
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity.and.ig<grp_ng) then
+!     ddop = pc_c*(elabfact-wl*grp_wlinv(ig+1))
+! New code
+  if((grd_isvelocity .or. grd_hydro_on) .and.ig<grp_ng) then
+     if( grd_hydro_on ) then
+       help = grd_dvdx(ix,iy,iz,1,1)
+     else
+       help = 1d0
+     endif
+     ddop = pc_c*(elabfact-wl*help*grp_wlinv(ig+1))
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if(ddop<0d0) then
         ddop = far
      endif
@@ -157,6 +201,13 @@
      mu = (xold*mu+d)/x
   endif
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
+
 !
 !-- updating time
   ptcl%t = ptcl%t + thelp*cinv*d
@@ -190,9 +241,17 @@
 
 !
 !-- updating transformation factors
-  if(grd_isvelocity) then
-     elabfact = 1d0 - mu*x*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity) then
+!     elabfact = 1d0 - mu*x*cinv
+!  endif
+! New code
+  if(grd_isvelocity.or.grd_hydro_on) then
+     elabfact = 1d0 - mu*vx*cinv
   endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 !
 !-- census
@@ -209,7 +268,15 @@
         mu = 0.0000001d0
      endif
 !-- checking velocity dependence
-     if(grd_isvelocity) mu=(mu+x*cinv)/(1d0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!     if(grd_isvelocity) mu=(mu+x*cinv)/(1d0+x*mu*cinv)
+! New code
+     if(grd_isvelocity.or.grd_hydro_on) then
+       mu=(mu+vx*cinv)/(1d0+vx*mu*cinv)
+     endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   elseif(d==db) then
      lout = mu>=0d0.and.ix==grd_nx
      if(lout) then
@@ -225,10 +292,19 @@
 !-- Thomson scatter
   if(d == dthm) then
 !-- checking velocity dependence
-     if(grd_isvelocity) then
 !-- lab wavelength
-        wl = wl*(1d0-mu*x*cinv)/elabfact        
-        help = elabfact/(1d0-mu*x*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!     if(grd_isvelocity) then
+!        wl = wl*(1d0-mu*x*cinv)/elabfact
+!        help = elabfact/(1d0-mu*x*cinv)
+! New code
+     if(grd_isvelocity .or. grd_hydro_on) then
+        wl = wl*(1d0-mu*vx*cinv)/elabfact
+        help = elabfact/(1d0-mu*vx*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- velocity effects accounting
         totevelo=totevelo+e*(1d0-help)
 !-- energy weight
@@ -252,8 +328,15 @@
      else
 !-- effective scattering
 !-- transforming to lab
-        if(grd_isvelocity) then
-           help = elabfact/(1d0-mu*x*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
+!           help = elabfact/(1d0-mu*x*cinv)
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+           help = elabfact/(1d0-mu*vx*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- velocity effects accounting
            totevelo = totevelo+e*(1d0-help)
 !-- energy weight
@@ -279,20 +362,40 @@
 !-- checking for DDMC in new group
         if(ptcl2%itype==2) then
 !-- transforming to cmf
-           if(grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
 !-- velocity effects accounting
-              totevelo = totevelo+e*x*mu*cinv
+!              totevelo = totevelo+e*x*mu*cinv
 !-- energy weight
-              e = e*(1d0-x*mu*cinv)
-              e0 = e0*(1d0-x*mu*cinv)
+!              e = e*(1d0-x*mu*cinv)
+!              e0 = e0*(1d0-x*mu*cinv)
+!           endif
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+!-- velocity effects accounting
+              totevelo = totevelo+e*vx*mu*cinv
+!-- energy weight
+              e = e*(1d0-vx*mu*cinv)
+              e0 = e0*(1d0-vx*mu*cinv)
            endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            wl = 0d0 !workaround ifort 13.1.3 bug
         else
 !-- uniformly in new group
            call rnd_r(r1,rndstate)
            wl = 1d0/((1d0-r1)*grp_wlinv(ig)+r1*grp_wlinv(ig+1))
 !-- converting comoving wavelength to lab frame wavelength
-           if(grd_isvelocity) wl = wl*(1d0-x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) wl = wl*(1d0-x*mu*cinv)
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+             wl = wl*(1d0-vx*mu*cinv)
+           endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
      endif
      
@@ -308,18 +411,37 @@
         x = grd_xarr(ix+1)
         ix = ix+1
         ic = grd_icell(ix,iy,iz)    
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+        call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else
 !-- DDMC in adjacent cell
-        if(grd_isvelocity) then
-           mu = (mu-x*cinv)/(1d0-x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
+!           mu = (mu-x*cinv)/(1d0-x*mu*cinv)
+!        endif
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+          mu = (mu-vx*cinv)/(1d0-vx*mu*cinv)
         endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         help= (grd_cap(ig,l)+grd_sig(l))*dx(ix+1)*thelp
         help = 4d0/(3d0*help+6d0*pc_dext)
 !-- sampling
         call rnd_r(r1,rndstate)
         if (r1 < help*(1d0+1.5*abs(mu))) then
            ptcl2%itype = 2
-           if(grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- velocity effects accounting
               totevelo=totevelo+e*(1d0-elabfact)
               e = e*elabfact
@@ -333,10 +455,23 @@
            call rnd_r(r1,rndstate)
            call rnd_r(r2,rndstate)
            mu = -max(r1,r2)
-           if(grd_isvelocity) then
-              mu = (mu+x*cinv)/(1d0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
+!              mu = (mu+x*cinv)/(1d0+x*mu*cinv)
+!           endif
+! New code
+           if(grd_isvelocity .or. grd_hydro_on) then
+              mu = (mu+vx*cinv)/(1d0+vx*mu*cinv)
            endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            x = grd_xarr(ix+1)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+           call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
      endif!}}}
 
@@ -352,11 +487,24 @@
         x = grd_xarr(ix)
         ix = ix-1
         ic = grd_icell(ix,iy,iz)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+        call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      else
 !-- DDMC in adjacent cell
-        if(grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
 !-- transforming x-cosine to cmf
-           mu = (mu-x*cinv)/(1d0-x*mu*cinv)
+!           mu = (mu-x*cinv)/(1d0-x*mu*cinv)
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+!-- transforming x-cosine to cmf
+           mu = (mu-vx*cinv)/(1d0-vx*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- amplification factor
            if(.not.trn_noampfact .and. mu<0d0) then
               help = 1d0/abs(mu)
@@ -379,7 +527,13 @@
         call rnd_r(r1,rndstate)
         if (r1 < help*(1d0+1.5d0*abs(mu))) then
            ptcl2%itype = 2
-           if(grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) then
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- velocity effects accounting
               totevelo = totevelo+e*(1d0-elabfact)
 !
@@ -395,15 +549,32 @@
            call rnd_r(r2,rndstate)
            mu = max(r1,r2)
 !-- transforming mu to lab
-           if(grd_isvelocity) mu=(mu+x*cinv)/(1d0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           if(grd_isvelocity) mu=(mu+x*cinv)/(1d0+x*mu*cinv)
+! New code
+           if(grd_isvelocity.or.grd_hydro_on) mu=(mu+vx*cinv)/(1d0+vx*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            x = grd_xarr(ix)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+           call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
      endif!}}}
 
 !
 !-- Doppler shift
   elseif(d == ddop) then
-     if(.not.grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!     if(.not.grd_isvelocity) then
+! New code
+     if((.not.grd_isvelocity).and.(.not.grd_hydro_on)) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !       stop 'transport11: ddop and no velocity'
         ierr = 16
         return
@@ -425,7 +596,13 @@
         ptcl2%itype = 2
         if(grd_isvelocity) then
 !-- velocity effects accounting
-           totevelo=totevelo+e*x*mu*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!           totevelo=totevelo+e*x*mu*cinv
+! New code
+           totevelo=totevelo+e*vx*mu*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !
            e = e*elabfact
            e0 = e0*elabfact
@@ -438,5 +615,12 @@
      return     
   endif
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
+
 end subroutine transport11
 ! vim: fdm=marker
diff -r d244a10db46e TRANSPORT1/transport11_gamgrey.f90
--- a/TRANSPORT1/transport11_gamgrey.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/TRANSPORT1/transport11_gamgrey.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -38,6 +38,13 @@
   integer,parameter :: iy=1,iz=1
   real*8,pointer :: x, mu, e, d
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  real*8, pointer :: vx
+
+  vx => ptcl2%vx
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
   ix => ptcl2%ix
   ic => ptcl2%ic
   d => ptcl2%dist
@@ -50,15 +57,35 @@
 !-- init
   edep = 0d0
 
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity) then
+!     siglabfact = 1.0d0 - mu*x*cinv
+!     dcollabfact = tsp_t*(1d0-mu*x*cinv)
+!     thelp = tsp_t
+!  else
+!     siglabfact = 1d0
+!     dcollabfact = 1d0
+!     thelp = 1d0
+!  endif
+! New code
   if(grd_isvelocity) then
-     siglabfact = 1.0d0 - mu*x*cinv
-     dcollabfact = tsp_t*(1d0-mu*x*cinv)
      thelp = tsp_t
   else
+     thelp = 1d0
+  endif
+  if(grd_isvelocity .or. grd_hydro_on) then
+     siglabfact = 1.0d0 - mu*vx*cinv
+     dcollabfact = tsp_t*(1d0-mu*vx*cinv)
+  else
      siglabfact = 1d0
      dcollabfact = 1d0
-     thelp = 1d0
   endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
   thelpinv = 1d0/thelp
 
 !-- distance longer than distance to census
@@ -116,11 +143,21 @@
   endif
 
 !-- transformation factor set
-  if(grd_isvelocity) then
-     elabfact = 1d0 - muold*rold*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity) then
+!     elabfact = 1d0 - muold*rold*cinv
+!  else
+!     elabfact = 1d0
+!  endif
+! New code
+  if(grd_isvelocity.or.grd_hydro_on) then
+     elabfact = 1d0 - muold*vx*cinv
   else
      elabfact = 1d0
   endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !calculating energy deposition and density
   !
   if(.not.trn_isimcanlog) then
@@ -131,12 +168,28 @@
 
   endif
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+     call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- transformation factor reset
-  if(grd_isvelocity) then
-     elabfact = 1d0 - mu*x*cinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!  if(grd_isvelocity) then
+!     elabfact = 1d0 - muold*rold*cinv
+!  else
+!     elabfact = 1d0
+!  endif
+! New code
+  if(grd_isvelocity.or.grd_hydro_on) then
+     elabfact = 1d0 - muold*vx*cinv
   else
      elabfact = 1d0
   endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 !
 !-- fictitious scattering with implicit capture
@@ -154,14 +207,28 @@
         if(abs(mu)<0.0000001d0) then
            mu = 0.0000001d0
         endif
-        if(grd_isvelocity) then
-           mu = (mu+x*cinv)/(1d0+x*mu*cinv)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(grd_isvelocity) then
+!           mu = (mu+x*cinv)/(1d0+x*mu*cinv)
 !-- velocity effects accounting
-           help = 1d0/(1d0-mu*x*cinv)
+!           help = 1d0/(1d0-mu*x*cinv)
+!
+!           e = e*elabfact*help
+!
+!       endif
+! New code
+        if(grd_isvelocity.or.grd_hydro_on) then
+           mu = (mu+vx*cinv)/(1d0+vx*mu*cinv)
+!-- velocity effects accounting
+           help = 1d0/(1d0-mu*vx*cinv)
 !
            e = e*elabfact*help
            
         endif
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !
         call rnd_r(r1,rndstate)
      endif
@@ -188,5 +255,7 @@
      ic = grd_icell(ix,iy,iz)!}}}
   endif
 
+  call hydro_velocity_at11(x, vx, ix, tsp_t)
+
 end subroutine transport11_gamgrey
 ! vim: fdm=marker
diff -r d244a10db46e dealloc_all.f
--- a/dealloc_all.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/dealloc_all.f	Thu Feb 15 15:27:16 2018 -0600
@@ -13,6 +13,10 @@
       use sourcemod
       use randommod
       use timestepmod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     MODIFICATION BY LSU
+      use hydromod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       implicit none
 ************************************************************************
 * deallocate all that was used till the end of the program. Any
@@ -20,6 +24,10 @@
 * with earlier.  This helps to catch memory leaks! (drr)
 ************************************************************************
 c-- ionsmod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     MODIFICATION BY LSU
+      call hydromod_dealloc
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call ions_dealloc
       call gas_dealloc
       call grid_dealloc
diff -r d244a10db46e gridmod.f
--- a/gridmod.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/gridmod.f	Thu Feb 15 15:27:16 2018 -0600
@@ -21,6 +21,16 @@
       real*8,allocatable :: grd_xarr(:)  !(nx+1), left cell edge values
       real*8,allocatable :: grd_yarr(:)  !(ny+1), left cell edge values
       real*8,allocatable :: grd_zarr(:)  !(nz+1), left cell edge values
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c        HYDRO LSU
+      logical :: grd_hydro_on = .false.
+      logical :: grd_radiation_on = .true.
+      real*8,allocatable :: grd_vx(:)
+      real*8,allocatable :: grd_vy(:)
+      real*8,allocatable :: grd_vz(:)
+      real*8,allocatable :: grd_v(:,:,:,:)
+      real*8,allocatable :: grd_dvdx(:,:,:,:,:)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
 c-- maximum radial grid velocity
       real*8 :: grd_rout=0d0   !particle flux edge radius
@@ -56,7 +66,10 @@
       real*8,allocatable :: grd_fcoef(:)  !(ncell)
 
 
-
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+      real*8,allocatable :: grd_momdep(:,:,:,:)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       real*8,allocatable :: grd_tally(:,:)   !(2,ncell) (edep,eraddens)
 c-- amplification factor excess
       real*8,allocatable :: grd_eamp(:)   !(ncell)
@@ -127,6 +140,15 @@
       allocate(grd_xarr(grd_nx+1))
       allocate(grd_yarr(grd_ny+1))
       allocate(grd_zarr(grd_nz+1))
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c        HYDRO LSU
+      allocate(grd_momdep(grd_nx,grd_ny,grd_nz,3))
+      allocate(grd_vx(grd_ncell))
+      allocate(grd_vy(grd_ncell))
+      allocate(grd_vz(grd_ncell))
+      allocate(grd_v(grd_nx,grd_ny,grd_nz,3))
+      allocate(grd_dvdx(grd_nx,grd_ny,grd_nz,3,3))
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c-- polar
       if(grd_igeom==1) allocate(grd_yacos(grd_ny+1))
 c
@@ -208,7 +230,101 @@
       deallocate(grd_emitprob)
 c-- ndim=4 alloc
       deallocate(grd_cap)!}}}
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c        HYDRO LSU
+      deallocate(grd_vx)
+      deallocate(grd_vy)
+      deallocate(grd_vz)
+      deallocate(grd_v)
+      deallocate(grd_dvdx)
+      deallocate(grd_momdep)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       end subroutine grid_dealloc
 c
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c        HYDRO LSU
+      pure subroutine hydro_velocity_at( x, y, z, vx, vy, vz,xi,yi,zi,t)
+      implicit none
+
+      real*8, intent(in) :: x, y, z, t
+      real*8, intent(out) ::vx, vy, vz
+      integer, intent(in) :: xi, yi, zi
+
+      real*8 :: dx, dy, dz
+
+      if( grd_hydro_on ) then
+        if( grd_igeom .ne. 11 ) then
+          dx = 0.5d0 * (x - grd_xarr(xi)) /
+     &                 (grd_xarr(xi+1) - grd_xarr(xi))
+          dy = 0.5d0 * (y - grd_yarr(yi)) /
+     &                 (grd_yarr(yi+1) - grd_yarr(yi))
+          dz = 0.5d0 * (z - grd_zarr(zi)) /
+     &                 (grd_zarr(zi+1) - grd_zarr(zi))
+          vx = grd_v(xi,yi,zi,1)
+          vy = grd_v(xi,yi,zi,2)
+          vz = grd_v(xi,yi,zi,3)
+          vx = vx + grd_dvdx(xi,yi,zi,1,1) * dx
+          vy = vy + grd_dvdx(xi,yi,zi,2,1) * dx
+          vz = vz + grd_dvdx(xi,yi,zi,3,1) * dx
+          vx = vx + grd_dvdx(xi,yi,zi,1,2) * dy
+          vy = vy + grd_dvdx(xi,yi,zi,2,2) * dy
+          vz = vz + grd_dvdx(xi,yi,zi,3,2) * dy
+          vx = vx + grd_dvdx(xi,yi,zi,1,3) * dz
+          vy = vy + grd_dvdx(xi,yi,zi,2,3) * dz
+          vz = vz + grd_dvdx(xi,yi,zi,3,3) * dz
+        else
+          dx = 0.5d0 * (x - grd_xarr(xi)) /
+     &                 (grd_xarr(xi+1) - grd_xarr(xi))
+          vx = grd_v(xi,yi,zi,1)
+          vx = vx + grd_dvdx(xi,yi,zi,1,1) * dx
+          vy = 0.0d0
+          vz = 0.0d0
+        endif
+      else if( grd_isvelocity ) then
+        vx = x
+        if( grd_igeom .ne. 1 .and. grd_igeom .ne. 11 ) then
+          vy = y
+        else
+          vy = 0.0d0
+        endif
+        if( grd_igeom .eq. 3 ) then
+          vz = z
+        else
+          vz = 0.0d0
+        endif
+      else
+        vx = 0.0d0
+        vy = 0.0d0
+        vz = 0.0d0
+       endif
+
+
+      end subroutine
+
+      pure subroutine hydro_velocity_at11( x, vx, xi, t )
+      implicit none
+
+      real*8, intent(in) :: x, t
+      real*8, intent(out) ::vx
+      integer, intent(in) :: xi
+
+      real*8 :: dx
+
+      if( grd_hydro_on ) then
+        dx = 0.5d0 * (x - grd_xarr(xi)) /
+     &                 (grd_xarr(xi+1) - grd_xarr(xi))
+        vx = grd_v(xi,1,1,1)
+        vx = vx + grd_dvdx(xi,1,1,1,1) * dx
+      else if( grd_isvelocity ) then
+        vx = x
+      else
+        vx = 0.0d0
+      endif
+
+
+      end subroutine
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
       end module gridmod
 c vim: fdm=marker
diff -r d244a10db46e inputparmod.f
--- a/inputparmod.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/inputparmod.f	Thu Feb 15 15:27:16 2018 -0600
@@ -23,6 +23,16 @@
       integer :: in_grd_igeom = 0 !geometry: 1=sph, 2=cyl, 3=car, 11=1Dsph
       integer :: in_ndim(3) = [1, 1, 1]  !number of x-direction cells
       logical :: in_isvelocity = .true.  !switch underlying grid between spatial+static to velocity+expanding
+
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+      logical :: in_hydro_on = .true.
+      logical :: in_radiation_on = .true.
+      integer :: in_test_problem = 0
+c                0 - no test, read from file or input params
+c                1 - Blast wave
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c
 c
 c-- read input structure file instead of specifying the stucture with input parameters
@@ -196,7 +206,12 @@
 !io
      & in_io_grabstdout,
      & in_io_nogriddump,in_io_dogrdtally,
-     & in_io_opacdump,in_io_pdensdump
+     & in_io_opacdump,in_io_pdensdump,
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     HYDRO LSU
+     & in_hydro_on, in_radiation_on, in_test_problem
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 c
 c-- pointers
 c
@@ -540,6 +555,10 @@
        stop 'in_grd_igeom invalid'
       endselect
 c
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MOD
+      if( in_test_problem .eq. 0 ) then
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       if(in_isvelocity) then
        if(in_str_lx>0d0) stop 'vel grid: use str_velout, not in_str_lx'
        if(in_str_ly>0d0) stop 'vel grid: use str_velout, not in_str_ly'
@@ -564,6 +583,10 @@
        if(in_str_dentype/='none') stop
      &   '!noreadstruct & str_dentype/=none'
       endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MOD
+      endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
 c-- special grid
       if(.not.in_noreadstruct) then
@@ -717,6 +740,10 @@
       use groupmod
       use gasmod
       use gridmod
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     MODIFICATION BY LSU
+      use hydromod
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       implicit none
       integer,intent(in) :: nmpi
 ************************************************************************
@@ -785,6 +812,11 @@
       grd_ny    = in_ndim(2)
       grd_nz    = in_ndim(3)
       grd_isvelocity = in_isvelocity
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     MODIFICATION BY LSU
+      grd_hydro_on = in_hydro_on
+      grd_radiation_on = in_radiation_on
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c!}}}
       end subroutine provide_inputpars
 c
diff -r d244a10db46e inputstrmod.f
--- a/inputstrmod.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/inputstrmod.f	Thu Feb 15 15:27:16 2018 -0600
@@ -20,6 +20,12 @@
       real*8,allocatable :: str_temp(:,:,:) !(nx,ny,nz)
       real*8,allocatable :: str_ye(:,:,:) !(nx,ny,nz)
       real*8,allocatable :: str_massfr(:,:,:,:) !(nabund,nx,ny,nz)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+      real*8,allocatable :: str_vx(:,:,:)
+      real*8,allocatable :: str_vy(:,:,:)
+      real*8,allocatable :: str_vz(:,:,:)
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
 c-- domain compression
       logical :: str_lvoid=.false.  !flag existence of void cells
@@ -143,6 +149,16 @@
       if(str_ltemp) allocate(str_temp(nx,ny,nz))
       if(str_lye) allocate(str_ye(nx,ny,nz))
       allocate(raw(ncol,nx*ny*nz))
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      allocate(str_vx(nx,ny,nz))
+      allocate(str_vy(nx,ny,nz))
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      allocate(str_vz(nx,ny,nz))
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
 c-- read body
       read(4,*,iostat=ierr) raw
@@ -340,6 +356,7 @@
 * put valid (non-void) cells in sequence, link the other (void) cells
 * to the dummy cell at the end of the sequence.
 ************************************************************************
+
       integer :: i,j,k,l
       integer :: idcell
 c
@@ -400,11 +417,50 @@
 c
       subroutine generate_inputstr(igeomin)
 c     ---------------------------------------------!{{{
-      implicit none
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+      use inputparmod
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc      implicit none
       integer,intent(in) :: igeomin
+      integer :: ini56
 ************************************************************************
 * wrapper around routines for different geometries
-************************************************************************
+**********************************
+
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+      if( in_test_problem .ne. 0 ) then
+         nx = in_ndim(1)
+         ny = in_ndim(2)
+         nz = in_ndim(3)
+         str_nabund = 1
+         allocate(str_abundlabl(1))
+         str_abundlabl(1) = 'h'
+         str_ltemp=.true.
+         allocate(str_mass(nx,ny,nz))
+         allocate(str_massfr(str_nabund,nx,ny,nz))
+         allocate(str_temp(nx,ny,nz))
+         allocate(str_xleft(nx+1))
+         allocate(str_yleft(nx+1))
+         allocate(str_zleft(nx+1))
+         allocate(str_ye(nx,ny,nz))
+         allocate(str_vx(nx,ny,nz))
+         allocate(str_vy(nx,ny,nz))
+         allocate(str_vz(nx,ny,nz))
+         call elnam2elcode(ini56)
+        select case(in_test_problem)
+          case(1)
+            write(*,*) 'Setting up Sedov-Taylor blast wave'
+            call sedov_setup
+        end select
+
+
+      else
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
+
+**************************************
       igeom = igeomin
       select case(igeom)
       case(1,11)
@@ -421,6 +477,11 @@
       if(.not.allocated(str_yleft)) allocate(str_yleft(2))
       if(.not.allocated(str_zleft)) allocate(str_zleft(2))
 c!}}}
+
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+      endif
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       end subroutine generate_inputstr
 c
 c
@@ -530,6 +591,8 @@
       allocate(str_zleft(nz+1))
       allocate(str_mass(nx,ny,nz))
 c
+
+
 c-- create unit cylinder radii xout
       dx = 1d0/nx
       forall(i=1:nx+1) xout(i) = (i-1)*dx
@@ -607,6 +670,9 @@
 c-- deallocating helper arrays
       deallocate(xout,yout)
 c!}}}
+
+
+
       end subroutine generate_inputstr2
 c
 c
@@ -782,7 +848,6 @@
         iabund = j
        endselect
        !write(6,*) 'el found: ',elname,iabund
-c
 c-- store element code (pointer to mass0fr)
        str_iabund(l) = iabund
       enddo!}}}
diff -r d244a10db46e ionsmod.f
--- a/ionsmod.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/ionsmod.f	Thu Feb 15 15:27:16 2018 -0600
@@ -299,6 +299,8 @@
        do istart=1,nion-1
         ion_el(iz)%i(istart)%n = 1d0 !use arbitrary start value for n_1
         do ii=istart+1,nion
+c        write(*,*)  sahac2,exp(-kti*ion_el(iz)%i(ii-1)%e),
+c     &     ion_el(iz)%i(ii-1)%n,ion_el(iz)%i(ii)%q,ion_el(iz)%i(ii-1)%q
          help = sahac2*exp(-kti*ion_el(iz)%i(ii-1)%e)*
      &     ion_el(iz)%i(ii-1)%n*ion_el(iz)%i(ii)%q/ion_el(iz)%i(ii-1)%q
          ion_el(iz)%i(ii)%n = help
diff -r d244a10db46e mpimod_ser.f
--- a/mpimod_ser.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/mpimod_ser.f	Thu Feb 15 15:27:16 2018 -0600
@@ -71,7 +71,176 @@
       subroutine allreduce_gammaenergy
       end subroutine allreduce_gammaenergy
 c
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c      HYDRO LSU
+      subroutine gather_hydro
+      use gridmod
+      use hydromod
+      use gasmod
+      use physconstmod
+      implicit none
+
+      integer :: i, j, k, l, f
+      integer :: i0, j0, k0, f0
+      real*8 :: eint
+
+      do i = hydro_bw+1, hydro_nx - hydro_bw
+      do j = hydro_bw+1, hydro_ny - hydro_bw
+      do k = hydro_bw+1, hydro_nz - hydro_bw
+         i0 = i - hydro_bw
+         j0 = j - hydro_bw
+         k0 = k - hydro_bw
+         l = grd_icell(i0, j0, k0)
+         hydro_state(i,j,k,rho_i) = gas_rho(l)
+         hydro_state(i,j,k,px_i) = grd_vx(l) * gas_rho(l)
+         hydro_state(i,j,k,py_i) = grd_vy(l) * gas_rho(l)
+         hydro_state(i,j,k,pz_i) = grd_vz(l) * gas_rho(l)
+         eint =  1.5d0*pc_kb*(1.0d0+gas_nelec(l))
+     &              * gas_natom(l) / gas_vol(l) * gas_temp(l)
+         hydro_state(i,j,k,tau_i) = eint**(1.0d0 / hydro_gamma)
+         hydro_state(i,j,k,natom_i) = gas_natom(l) / gas_vol(l)
+         if( grd_igeom .eq. 11 ) then
+           hydro_state(i,j,k,egas_i) = eint +
+     &                               0.5d0*grd_vx(l)**2 * gas_rho(l)
+         else
+           hydro_state(i,j,k,egas_i) = eint + 0.5d0*
+     &     (grd_vx(l)**2 + grd_vy(l)**2 + grd_vz(l)**2) * gas_rho(l)
+         endif
+         f = frac_i
+         do f0 = 1, gas_nelem
+           hydro_state(i,j,k,f) = gas_natom1fr(f0,l) * gas_natom(l)
+     &                                               / gas_vol(l)
+           f = f + 1
+         enddo
+         do f0 = -2*gas_nchain, -1
+           hydro_state(i,j,k,f) = gas_natom1fr(f0,l) * gas_natom(l) /
+     &                                                 gas_vol(l)
+           f = f + 1
+         enddo
+c         write(*,*) i,j,k,gas_nelem,gas_natom1fr(1:gas_nelem,l)
+         hydro_state(i,j,k,nelec_i) = gas_nelec(l) * gas_natom(l)
+     &                                             / gas_vol(l)
+      enddo
+      enddo
+      enddo
+      end subroutine gather_hydro
+
+
+      subroutine scatter_hydro
+      use gridmod
+      use hydromod
+      use gasmod
+      use physconstmod
+      use timestepmod
+      use elemdatamod
+      implicit none
+
+      integer :: i, j, k, l, f
+      integer :: i0, j0, k0, f0
+      real*8 :: natom
+      real*8 :: eint, nnuc
+      do i = hydro_bw+1, hydro_nx - hydro_bw
+      do j = hydro_bw+1, hydro_ny - hydro_bw
+      do k = hydro_bw+1, hydro_nz - hydro_bw
+         i0 = i - hydro_bw
+         j0 = j - hydro_bw
+         k0 = k - hydro_bw
+         l = grd_icell(i0, j0, k0)
+         if( grd_isvelocity) then
+           gas_vol(l) = gas_vol(l) * (1.0d0 + tsp_dt / tsp_t )**3
+         endif
+         gas_rho(l) = hydro_state(i,j,k,rho_i)
+         grd_vx(l) = hydro_state(i,j,k,px_i) / gas_rho(l)
+         grd_vy(l) = hydro_state(i,j,k,py_i) / gas_rho(l)
+         grd_vz(l) = hydro_state(i,j,k,pz_i) / gas_rho(l)
+         eint = hydro_state(i,j,k,egas_i) -
+     &          (grd_vx(l)**2+grd_vy(l)**2+grd_vz(l)**2)*0.50d0*
+     &              hydro_state(i,j,k,rho_i)
+         if( eint .le. hydro_state(i,j,k,egas_i) * 0.001d0 ) then
+           eint = hydro_state(i,j,k,tau_i)**(hydro_gamma)
+         endif
+
+
+         f = frac_i
+         do f0 = 1, gas_nelem
+           gas_natom1fr(f0,l) = hydro_state(i,j,k,f) * gas_vol(l)
+           f = f + 1
+         enddo
+         do f0 = -2*gas_nchain, -1
+           gas_natom1fr(f0,l) = hydro_state(i,j,k,f) * gas_vol(l)
+           f = f + 1
+         enddo
+         gas_natom(l) = 0.0d0
+         nnuc = 0.0d0
+         do f = 1, gas_nelem
+           natom = gas_natom1fr(f,l)
+           nnuc = nnuc + natom * elem_data(f)%m
+           gas_natom(l) = gas_natom(l) + natom
+         enddo
+         gas_natom(l) = hydro_state(i,j,k,natom_i) * gas_vol(l)
+         gas_nelec(l) = hydro_state(i,j,k,nelec_i) * gas_vol(l)
+     &                                             / gas_natom(l)
+         gas_ye(l) = gas_nelec(l) / nnuc
+c         gas_nelec(l) = gas_nelec(l) / gas_natom(l)
+         gas_bcoef(l) = 1.5d0*pc_kb*(1d0+gas_nelec(l))
+     &              * gas_natom(l) / gas_vol(l)
+         gas_temp(l) =    eint / gas_bcoef(l)
+         gas_temp(l) = max(gas_temp(l),3d3)
+c         write(*,*) l, gas_temp(l), eint, gas_bcoef(l)
+      enddo
+      enddo
+      enddo
+
+
+      do i = 1, gas_ncell
+        gas_natom1fr(28,i) = gas_natom1fr(28,i) -
+     &   gas_natom1fr(gas_ini56,i)
+        gas_natom1fr(27,i) = gas_natom1fr(27,i) -
+     &   gas_natom1fr(gas_ico56,i)
+        gas_natom1fr(26,i) = gas_natom1fr(26,i) -
+     &   gas_natom1fr(gas_ife52,i)
+        gas_natom1fr(25,i) = gas_natom1fr(25,i) -
+     &   gas_natom1fr(gas_imn52,i)
+        gas_natom1fr(24,i) = gas_natom1fr(24,i) -
+     &   gas_natom1fr(gas_icr48,i)
+        gas_natom1fr(23,i) = gas_natom1fr(23,i) -
+     &   gas_natom1fr(gas_iv48,i)
+
+        gas_natom0fr(-2,i,1) = gas_natom1fr(gas_ini56,i)!unstable
+        gas_natom0fr(-1,i,1) = gas_natom1fr(gas_ico56,i)!unstable
+        gas_natom0fr(0:2,i,1) = gas_natom1fr(26:28,i)!stable
+c-- fe/mn/cr
+        gas_natom0fr(-2,i,2) = gas_natom1fr(gas_ife52,i)!unstable
+        gas_natom0fr(-1,i,2) = gas_natom1fr(gas_imn52,i)!unstable
+        gas_natom0fr(0:2,i,2) = gas_natom1fr(24:26,i)!stable
+c-- cr/v/ti
+        gas_natom0fr(-2,i,3) = gas_natom1fr(gas_icr48,i)!unstable
+        gas_natom0fr(-1,i,3) = gas_natom1fr(gas_iv48,i)!unstable
+        gas_natom0fr(0:2,i,3) = gas_natom1fr(22:24,i)!stable
 c
+        gas_natom1fr(28,i) = gas_natom1fr(28,i) +
+     &   gas_natom1fr(gas_ini56,i)
+        gas_natom1fr(27,i) = gas_natom1fr(27,i) +
+     &   gas_natom1fr(gas_ico56,i)
+        gas_natom1fr(26,i) = gas_natom1fr(26,i) +
+     &   gas_natom1fr(gas_ife52,i)
+        gas_natom1fr(25,i) = gas_natom1fr(25,i) +
+     &   gas_natom1fr(gas_imn52,i)
+        gas_natom1fr(24,i) = gas_natom1fr(24,i) +
+     &   gas_natom1fr(gas_icr48,i)
+        gas_natom1fr(23,i) = gas_natom1fr(23,i) +
+     &   gas_natom1fr(gas_iv48,i)
+c
+        gas_natom(i) = sum(gas_natom1fr(1:,i))
+        gas_natom1fr(:,i) = gas_natom1fr(:,i)/gas_natom(i)
+        gas_natom0fr(:,i,:) = gas_natom0fr(:,i,:)/gas_natom(i)
+      enddo
+
+
+c      call abort()
+
+      end subroutine scatter_hydro
+cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       subroutine bcast_nonpermanent
       use gridmod
       use gasmod
diff -r d244a10db46e particle_advance.f90
--- a/particle_advance.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/particle_advance.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -4,6 +4,10 @@
 subroutine particle_advance
 
 !$ use omp_lib
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!    LSU MODIFICATION
+  use hydromod
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   use randommod
   use transportmod
   use miscmod
@@ -39,6 +43,12 @@
   integer, pointer :: ig, ic
   integer, pointer :: ix, iy, iz
   real*8, pointer :: x,y,z, mu, e, e0, wl, om
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!    LSU MODIFICATION
+  real*8, pointer :: vx, vy, vz
+  real*8 :: momb(3), mome(3), this_dt, help2
+  integer :: ixold, iyold, izold, itypeold, icxp, icxm, icyp, icym, iczp, iczm
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   real*8 :: eta, xi
   real*8 :: t0,t1  !timing
   real*8 :: labfact, mu1, mu2
@@ -138,6 +148,13 @@
   x => ptcl%x
   y => ptcl%y
   z => ptcl%z
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!    LSU MODIFICATION
+  grd_momdep = 0d0
+  vx => ptcl2%vx
+  vy => ptcl2%vy
+  vz => ptcl2%vz
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   mu => ptcl%mu
   om => ptcl%om
   wl => ptcl%wl
@@ -184,6 +201,12 @@
      !if(ptcl%t<tsp_t) write(0,*) ptcl%t,tsp_t,(ptcl%t-tsp_t)/(ptcl%t+tsp_t),x
      if(ptcl%t<tsp_t) stop 'particle_advance: ptcl%t < tsp_t'
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+     call hydro_velocity_at(x, y, z, vx, vy, vz, ix, iy, iz, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !
 !-- determine particle type
      select case(grd_igeom)
@@ -206,18 +229,39 @@
 
 !
 !-- transform IMC particle into lab frame
-     if(grd_isvelocity.and.ptcl2%itype==1) then
-        select case(grd_igeom)
-        case(1,11)
-           labfact = 1d0-x*mu/pc_c
-        case(2)
-           labfact = 1d0-(mu*y + sqrt(1d0-mu**2) * cos(om)*x)/pc_c
-        case(3)
-           help = sqrt(1d0-mu**2)
-           mu1 = help*cos(om)
-           mu2 = help*sin(om)
-           labfact = 1d0-(mu*z + mu1*x + mu2*y)/pc_c
-        endselect
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! MODIFIED BY LSU
+! Old code -
+!     if(grd_isvelocity.and.ptcl2%itype==1) then
+!        select case(grd_igeom)
+!        case(1,11)
+!           labfact = 1d0-x*mu/pc_c
+!        case(2)
+!           labfact = 1d0-(mu*y + sqrt(1d0-mu**2) * cos(om)*x)/pc_c
+!        case(3)
+!           help = sqrt(1d0-mu**2)
+!           mu1 = help*cos(om)
+!           mu2 = help*sin(om)
+!           labfact = 1d0-(mu*z + mu1*x + mu2*y)/pc_c
+!        endselect
+! New code -
+     if((grd_isvelocity.or.grd_hydro_on).and.ptcl2%itype==1) then
+        if( grd_igeom .eq. 11 ) then
+          labfact = 1d0 - mu*vx/pc_c
+        else
+           help2 = sqrt(1d0-mu**2)
+           mu1 = help2*cos(om)
+           mu2 = help2*sin(om)
+          select case(grd_igeom)
+          case(1)
+             labfact = 1d0-(mu*vx + mu1*vy + mu2*vz)/pc_c
+          case(2)
+             labfact = 1d0-(mu*vy + mu1*vx + mu2*vz)/pc_c
+          case(3)
+             labfact = 1d0-(mu*vz + mu1*vx + mu2*vy)/pc_c
+          endselect
+        endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !-- transform into lab frame
         wl = wl*labfact
         e = e/labfact
@@ -228,6 +272,7 @@
 !-- First portion of operator split particle velocity position adjustment
      if(grd_isvelocity.and.ptcl2%itype==1) then
         call advection(.true.,ptcl,ptcl2) !procedure pointer to advection[123]
+        call hydro_velocity_at(x, y, z, vx, vy, vz, ix, iy, iz, tsp_t)
      endif
 
 !-- velocity components in cartesian basis
@@ -258,6 +303,21 @@
 
      do while (ptcl2%stat=='live')
         ptcl2%istep = ptcl2%istep + 1
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+        if( grd_hydro_on ) then
+          itypeold = ptcl2%itype
+          ixold = ix
+          iyold = iy
+          izold = iz
+          this_dt = ptcl%t
+          if( ptcl2%itype .eq. 1 ) then
+            call particle_momentum( ptcl, momb )
+          else
+            momb = 0d0
+          endif
+        endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         icold = ic
         if(ptcl2%itype==1 .or. in_puretran) then
            nstepimc = nstepimc + 1
@@ -280,6 +340,75 @@
         ndist(i) = ndist(i) + 1
 !-- tally rest
         grd_tally(:,icold) = grd_tally(:,icold) + [edep,eraddens]
+
+
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+        if( grd_hydro_on ) then
+          if( itypeold .eq. 2 ) then
+            this_dt = ptcl%t - this_dt
+
+            help2 = eraddens * this_dt / 2d0 * dx(ixold)
+            if( ixold .gt. 1 ) then
+              icxm = grd_icell(ixold-1,iyold,izold)
+              grd_momdep(ixold-1,iyold,izold,1)=grd_momdep(ixold-1,iyold,izold,1) - &
+                                     help2 * (grd_sig(icxm)+grd_cap(ig,icxm)) * grd_opaclump(1,icold)
+            endif
+            if( ixold .lt. grd_nx ) then
+              icxp = grd_icell(ixold+1,iyold,izold)
+              grd_momdep(ixold+1,iyold,izold,1)=grd_momdep(ixold+1,iyold,izold,1) + &
+                                     help2 * (grd_sig(icxp)+grd_cap(ig,icxp)) * grd_opaclump(2,icold)
+            endif
+            grd_momdep(ixold,iyold,izold,1)=grd_momdep(ixold,iyold,izold,1) - &
+                                     help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(1,icold)
+            grd_momdep(ixold,iyold,izold,1)=grd_momdep(ixold,iyold,izold,1) + &
+                                     help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(2,icold)
+
+            if( grd_igeom .ne. 11 ) then
+
+              help2 = eraddens * this_dt / 2d0 * dy(iyold)
+              if( iyold .gt. 1 ) then
+                icym = grd_icell(ixold,iyold-1,izold)
+                grd_momdep(ixold,iyold-1,izold,2)=grd_momdep(ixold,iyold-1,izold,2) - &
+                                       help2 * (grd_sig(icym)+grd_cap(ig,icym)) * grd_opaclump(3,icold)
+              endif
+              if( iyold .lt. grd_ny ) then
+                icyp = grd_icell(ixold,iyold+1,izold)
+                grd_momdep(ixold,iyold+1,izold,2)=grd_momdep(ixold,iyold+1,izold,2) + &
+                                       help2 * (grd_sig(icyp)+grd_cap(ig,icyp)) * grd_opaclump(4,icold)
+              endif
+              grd_momdep(ixold,iyold,izold,2)=grd_momdep(ixold,iyold,izold,2) - &
+                                       help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(3,icold)
+              grd_momdep(ixold,iyold,izold,2)=grd_momdep(ixold,iyold,izold,2) + &
+                                      help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(4,icold)
+
+              help2 = eraddens * this_dt / 2d0 * dz(izold)
+              if( izold .gt. 1 ) then
+                iczm = grd_icell(ixold,iyold,izold-1)
+                grd_momdep(ixold,iyold,izold-1,3)=grd_momdep(ixold,iyold,izold-1,3) - &
+                                       help2 * (grd_sig(iczm)+grd_cap(ig,iczm)) * grd_opaclump(5,icold)
+              endif
+              if( izold .lt. grd_nz ) then
+                iczp = grd_icell(ixold,iyold,izold+1)
+                grd_momdep(ixold,iyold,izold+1,3)=grd_momdep(ixold,iyold,izold+1,3) + &
+                                       help2 * (grd_sig(iczp)+grd_cap(ig,iczp)) * grd_opaclump(6,icold)
+              endif
+              grd_momdep(ixold,iyold,izold,3)=grd_momdep(ixold,iyold,izold,  3) - &
+                                       help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(5,icold)
+              grd_momdep(ixold,iyold,izold,3)=grd_momdep(ixold,iyold,izold,  3) + &
+                                       help2 * (grd_sig(icold)+grd_cap(ig,icold)) * grd_opaclump(6,icold)
+            endif
+          endif
+          if( ptcl2%itype .eq. 1 ) then
+            call particle_momentum( ptcl, mome )
+          else
+            mome = 0d0
+          endif
+          grd_momdep(ix,iy,iz,:) = grd_momdep(ix,iy,iz,:) + momb - mome
+        endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
+
 !
 !-- Russian roulette for termination of exhausted particles
         if(e<1d-6*e0 .and. ptcl2%stat=='live' .and. &
@@ -288,16 +417,36 @@
            if(.not.grd_isvelocity .or. ptcl2%itype==2) then
               labfact = 1d0
            else
-              select case(grd_igeom)
-              case(1,11)
-                 labfact = 1d0 - mu*x/pc_c
-              case(2)
-                 labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * &
-                    cos(om)*x)/pc_c
-              case(3)
-                 labfact = 1d0-(mu*z+sqrt(1d0-mu**2) * &
-                    (cos(om)*x+sin(om)*y))/pc_c
-              endselect
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! MODIFIED BY LSU
+! Old code -
+!              select case(grd_igeom)
+!              case(1,11)
+!                 labfact = 1d0 - mu*x/pc_c
+!              case(2)
+!                 labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * &
+!                    cos(om)*x)/pc_c
+!              case(3)
+!                 labfact = 1d0-(mu*z+sqrt(1d0-mu**2) * &
+!                    (cos(om)*x+sin(om)*y))/pc_c
+!              endselect
+! New code -
+             if( grd_igeom .eq. 11 ) then
+               labfact = 1d0 - mu*vx/pc_c
+             else
+               help2 = sqrt(1d0-mu**2)
+               mu1 = help2*cos(om)
+               mu2 = help2*sin(om)
+               select case(grd_igeom)
+                 case(1)
+                   labfact = 1d0-(mu*vx + mu1*vy + mu2*vz)/pc_c
+                 case(2)
+                   labfact = 1d0-(mu*vy + mu1*vx + mu2*vz)/pc_c
+                 case(3)
+                   labfact = 1d0-(mu*vz + mu1*vx + mu2*vy)/pc_c
+               endselect
+             endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            endif
 !
            call rnd_r(r1,rndstate)
@@ -397,14 +546,31 @@
 
 !
 !-- Redshifting DDMC particle energy weights and wavelengths
-        if(ptcl2%itype==2 .and. grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!        if(ptcl2%itype==2 .and. grd_isvelocity) then
 !-- r   edshifting energy weight!{{{
-           tot_evelo = tot_evelo + e*(1d0-exp(-tsp_dt/tsp_t))
-           e = e*exp(-tsp_dt/tsp_t)
-           e0 = e0*exp(-tsp_dt/tsp_t)
-           !
+!           tot_evelo = tot_evelo + e*(1d0-exp(-tsp_dt/tsp_t))
+!           e = e*exp(-tsp_dt/tsp_t)
+!           e0 = e0*exp(-tsp_dt/tsp_t)
+! New code
+        if(ptcl2%itype==2 .and. (grd_isvelocity.or.grd_hydro_on)) then
+!-- r   edshifting energy weight!{{{
+           if( grd_hydro_on ) then
+             help = 2d0/(grd_xarr(ix+1)+grd_xarr(ix))
+             help = mu*mu*grd_dvdx(ix,iy,iz,1,1) + (1d0-mu*mu)*grd_v(ix,iy,iz,1)*help
+           else
+             help = 1d0
+           endif
+           help = 1d0 / tsp_t
+           tot_evelo = tot_evelo + e*(1d0-exp(-tsp_dt*help))
+           e = e*exp(-tsp_dt*help)
+           e0 = e0*exp(-tsp_dt*help)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !
-!-- f   ind group
+!
+!-- find group
            ig = binsrch(wl,grp_wl,grp_ng+1,.false.)
 !
            call rnd_r(r1,rndstate)
@@ -420,6 +586,7 @@
 
         if(grd_isvelocity.and.ptcl2%itype==1) then
            call advection(.false.,ptcl,ptcl2) !procedure pointer to advection[123]
+           call hydro_velocity_at(x, y, z, vx, vy, vz, ix, iy, iz, tsp_t)
         endif
 
 !-- renergy at census
@@ -467,25 +634,54 @@
            call rnd_r(r1,rndstate)
            om = pc_pi2*r1
 !
-           if(grd_isvelocity) call direction2lab(x,y,z,mu,om)
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! MODIFIED BY LSU
+! Old code -
+!           if(grd_isvelocity) call direction2lab(x,y,z,mu,om)
+! New code -
+            if(grd_isvelocity.or.grd_hydro_on) then
+              call hydro_velocity_at(x, y, z, vx, vy, vz, ix, iy, iz, tsp_t)
+              call direction2lab(vx,vy,vz,mu,om)
+            endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         endif
 
 !
 !-- transform IMC particle energy to comoving frame for storage
         if(grd_isvelocity.and.ptcl2%itype==1) then
-           select case(grd_igeom)
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! MODIFIED BY LSU
+! Old code -
+!           select case(grd_igeom)
 !-- [123]D spherical
-           case(1,11)
-              labfact = 1d0-x*mu/pc_c
+!           case(1,11)
+!              labfact = 1d0-x*mu/pc_c
 !-- 2D
-           case(2)
-              labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * cos(om)*x)/pc_c
+!           case(2)
+!              labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * cos(om)*x)/pc_c
 !-- 3D
-           case(3)
-              mu1 = sqrt(1d0-mu**2)*cos(om)
-              mu2 = sqrt(1d0-mu**2)*sin(om)
-              labfact = 1d0-(mu*z+mu1*x+mu2*y)/pc_c
-           endselect
+!           case(3)
+!              mu1 = sqrt(1d0-mu**2)*cos(om)
+!              mu2 = sqrt(1d0-mu**2)*sin(om)
+!              labfact = 1d0-(mu*z+mu1*x+mu2*y)/pc_c
+!           endselect
+! New code -
+           if( grd_igeom .eq. 11 ) then
+             labfact = 1d0 - mu*vx/pc_c
+           else
+             help = sqrt(1d0-mu**2)
+             mu1 = help*cos(om)
+             mu2 = help*sin(om)
+             select case(grd_igeom)
+               case(1)
+                 labfact = 1d0-(mu*vx + mu1*vy + mu2*vz)/pc_c
+               case(2)
+                 labfact = 1d0-(mu*vy + mu1*vx + mu2*vz)/pc_c
+               case(3)
+                 labfact = 1d0-(mu*vz + mu1*vx + mu2*vy)/pc_c
+             endselect
+           endif
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 !-- apply inverse labfact for symmetry (since gamma factor is missing)
            wl = wl/labfact
diff -r d244a10db46e particle_advance_gamgrey.f90
--- a/particle_advance_gamgrey.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/particle_advance_gamgrey.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -36,9 +36,13 @@
   real*8,pointer :: x,y,z,mu,om,e,e0
   real*8 :: eta, xi
   real*8 :: t0,t1  !timing
-  real*8 :: labfact, cmffact, mu1, mu2, gm
+  real*8 :: labfact, cmffact, mu1, mu2!, gm
   real*8 :: etot,pwr
   real*8 :: om0, mu0, x0, y0, z0
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  real*8,pointer :: vx, vy, vz
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !
   integer :: nvol(grd_ncell)
 !
@@ -123,7 +127,7 @@
 
 !$omp parallel &
 !$omp shared(nvol) &
-!$omp private(ptcl,ptcl2,x0,y0,z0,mu0,om0,cmffact,gm,mu1,mu2,eta,xi,labfact,iom,imu, &
+!$omp private(ptcl,ptcl2,mu0,om0,cmffact,mu1,mu2,eta,xi,labfact,iom,imu, &
 !$omp    rndstate,edep,ierr, iomp, &
 !$omp    x,y,z,mu,om,e,e0,ix,iy,iz,ic,icold,r1, &
 !$omp    i,j,k) &
@@ -139,6 +143,12 @@
   x => ptcl%x
   y => ptcl%y
   z => ptcl%z
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+  vx => ptcl2%vx
+  vy => ptcl2%vy
+  vz => ptcl2%vz
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   mu => ptcl%mu
   om => ptcl%om
   e => ptcl%e
@@ -190,6 +200,13 @@
      call rnd_r(r1,rndstate)
      z = r1*grd_zarr(k+1) + (1d0-r1) * grd_zarr(k)
 
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! compute fluid velocity at particle position
+     call hydro_velocity_at11(x, vx, ix, tsp_t)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- direction cosine (comoving)
      call rnd_r(r1,rndstate)
      mu0 = 1d0-2d0*r1
@@ -197,50 +214,86 @@
      om0 = pc_pi2*r1
 
 !-- transform direction
-     if(.not.grd_isvelocity) then
-         mu = mu0
-         om = om0
-     else
-        select case(grd_igeom)!{{{
-        case(1,11)
-           x0 = x
-           cmffact = 1d0+mu0*x0/pc_c !-- 1+dir*v/c
-           mu = (mu0+x0/pc_c)/cmffact
-           om = om0
-        case(2)
-           x0 = x
-           y0 = y
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+
+! Old
+!     if(.not.grd_isvelocity) then
+!         mu = mu0
+!         om = om0
+!     else
+!        select case(grd_igeom)!{{{
+!        case(1,11)
+!           x0 = x
+!           cmffact = 1d0+mu0*x0/pc_c !-- 1+dir*v/c
+!           mu = (mu0+x0/pc_c)/cmffact
+!           om = om0
+!        case(2)
+!           x0 = x
+!           y0 = y
 !-- 1+dir*v/c
-           cmffact = 1d0+(mu0*y0+sqrt(1d0-mu0**2)*cos(om0)*x0)/pc_c
-           gm = 1d0/sqrt(1d0-(x**2+y**2)/pc_c**2)
+!           cmffact = 1d0+(mu0*y0+sqrt(1d0-mu0**2)*cos(om0)*x0)/pc_c
+!           gm = 1d0/sqrt(1d0-(x**2+y**2)/pc_c**2)
 !-- om
-           om = atan2(sqrt(1d0-mu0**2)*sin(om0) , &
-                sqrt(1d0-mu0**2)*cos(om0)+(gm*x/pc_c) * &
-                (1d0+gm*(cmffact-1d0)/(gm+1d0)))
-           if(om<0d0) om = om+pc_pi2
+!           om = atan2(sqrt(1d0-mu0**2)*sin(om0) , &
+!                sqrt(1d0-mu0**2)*cos(om0)+(gm*x/pc_c) * &
+!                (1d0+gm*(cmffact-1d0)/(gm+1d0)))
+!           if(om<0d0) om = om+pc_pi2
 !-- mu
-           mu = (mu0+(gm*y/pc_c)*(1d0+gm*(cmffact-1d0)/(1d0+gm))) / &
-                (gm*cmffact)
-        case(3)
-           x0 = x
-           y0 = y
-           z0 = z
+!           mu = (mu0+(gm*y/pc_c)*(1d0+gm*(cmffact-1d0)/(1d0+gm))) / &
+!                (gm*cmffact)
+!        case(3)
+!           x0 = x
+!           y0 = y
+!           z0 = z
 !-- 1+dir*v/c
-           mu1 = sqrt(1d0-mu0**2)*cos(om0)
-           mu2 = sqrt(1d0-mu0**2)*sin(om0)
-           cmffact = 1d0+(mu0*z0+mu1*x0+mu2*y0)/pc_c
+!           mu1 = sqrt(1d0-mu0**2)*cos(om0)
+!           mu2 = sqrt(1d0-mu0**2)*sin(om0)
+!           cmffact = 1d0+(mu0*z0+mu1*x0+mu2*y0)/pc_c
 !-- mu
-           mu = (mu0+z0/pc_c)/cmffact
-           if(mu>1d0) then
-              mu = 1d0
-           elseif(mu<-1d0) then
-              mu = -1d0
-           endif
+!           mu = (mu0+z0/pc_c)/cmffact
+!           if(mu>1d0) then
+!              mu = 1d0
+!           elseif(mu<-1d0) then
+!              mu = -1d0
+!           endif
 !-- om
-           om = atan2(mu2+y0/pc_c,mu1+x0/pc_c)
-           if(om<0d0) om = om+pc_pi2
-        endselect!}}}
+!           om = atan2(mu2+y0/pc_c,mu1+x0/pc_c)
+!           if(om<0d0) om = om+pc_pi2
+!        endselect!}}}
+!     endif
+
+! New code
+        if( grd_igeom .eq. 11 ) then
+          cmffact = 1d0 + mu0*vx/pc_c
+        else
+           help = sqrt(1d0-mu0**2)
+           mu1 = help*cos(om0)
+           mu2 = help*sin(om0)
+          select case(grd_igeom)
+          case(1)
+             cmffact = 1d0+(mu0*vx + mu1*vy + mu2*vz)/pc_c
+          case(2)
+             cmffact = 1d0+(mu0*vy + mu1*vx + mu2*vz)/pc_c
+          case(3)
+             cmffact = 1d0+(mu0*vz + mu1*vx + mu2*vy)/pc_c
+          endselect
+        endif
+
+     if(grd_isvelocity.or.grd_hydro_on) then
+       if( grd_igeom .eq. 11 ) then
+         call direction2lab11(vx,mu0)
+         om0 = 0d0
+       else
+         call direction2lab(vx,vy,vz,mu0,om0)
+       endif
      endif
+     mu = mu0
+     om = om0
+
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 !-- velocity components in cartesian basis
      if(grd_igeom==1) then
@@ -263,7 +316,15 @@
 !
 !-- emission energy per particle
      e = grd_emitex(ic)/nvol(ic)
-     if(grd_isvelocity) e = e*cmffact
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+
+! Old code
+!     if(grd_isvelocity) e = e*cmffact
+
+! New code
+     if(grd_isvelocity.or.grd_hydro_on) e = e*cmffact
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      e0 = e
 
 !-----------------------------------------------------------------------
@@ -277,7 +338,9 @@
      do while (ptcl2%stat=='live')
         ptcl2%istep = ptcl2%istep + 1
         icold = ic
+        call hydro_velocity_at11(x, vx, ix, tsp_t)
         call transport_gamgrey(ptcl,ptcl2,rndstate,edep,ierr)
+        call hydro_velocity_at11(x, vx, ix, tsp_t)
 !-- tally
         grd_tally(1,icold) = grd_tally(1,icold) + edep
 
@@ -286,17 +349,38 @@
            call rnd_r(r1,rndstate)!{{{
            if(r1<0.5d0) then
 !-- transformation factor
-              if(grd_isvelocity) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+! Old code
+!             if(grd_isvelocity) then
+!                 select case(grd_igeom)
+!                 case(1,11)
+!                    labfact = 1.0d0 - mu*x/pc_c
+!                 case(2)
+!                    labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * &
+!                         cos(om)*x)/pc_c
+!                 case(3)
+!                    labfact = 1d0-(mu*z+sqrt(1d0-mu**2) * &
+!                         (cos(om)*x+sin(om)*y))/pc_c
+!                 endselect
+! New code
+             if((grd_isvelocity.or.grd_hydro_on)) then
+               if( grd_igeom .eq. 11 ) then
+                 labfact = 1d0 - mu*vx/pc_c
+               else
+                 help = sqrt(1d0-mu**2)
+                 mu1 = help*cos(om)
+                 mu2 = help*sin(om)
                  select case(grd_igeom)
-                 case(1,11)
-                    labfact = 1.0d0 - mu*x/pc_c
-                 case(2)
-                    labfact = 1d0-(mu*y+sqrt(1d0-mu**2) * &
-                         cos(om)*x)/pc_c
-                 case(3)
-                    labfact = 1d0-(mu*z+sqrt(1d0-mu**2) * &
-                         (cos(om)*x+sin(om)*y))/pc_c
+                   case(1)
+                     labfact = 1d0-(mu*vx + mu1*vy + mu2*vz)/pc_c
+                   case(2)
+                     labfact = 1d0-(mu*vy + mu1*vx + mu2*vz)/pc_c
+                   case(3)
+                     labfact = 1d0-(mu*vz + mu1*vx + mu2*vy)/pc_c
                  endselect
+               endif
+ !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
               else
                  labfact = 1d0
               endif
@@ -363,6 +447,9 @@
            labfact = (mu*z+sqrt(1d0-mu**2) * &
                 (cos(om)*x+sin(om)*y))/pc_c
         endselect
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION (pending)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         if(grd_isvelocity) labfact=labfact*tsp_t
         help=help-labfact
 !-- tally outbound luminosity        
diff -r d244a10db46e particlemod.f90
--- a/particlemod.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/particlemod.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -16,6 +16,10 @@
      real*8 :: dist          !particle travel distance
      character(4) :: stat    !particle status: live, cens, flux, dead
      integer :: ix, iy, iz   !positional cell indices
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+! LSU MODIFICATION
+     real*8 :: vx, vy, vz   !fluid velocities
+!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      integer :: ic, ig       !index into compressed domain arrays, group index
      integer :: itype        !IMC or DDMC type
      integer :: ipart, istep !particle number and transport step number
diff -r d244a10db46e supernu.f90
--- a/supernu.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/supernu.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -24,7 +24,10 @@
   use ffxsmod, only:ffxs_read_data
   use timingmod
   use countersmod
-
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     MODIFICATION BY LSU
+  use hydromod
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   implicit none
 !***********************************************************************
 ! TODO and wishlist:
@@ -70,7 +73,7 @@
        call generate_inputstr(in_grd_igeom)
      endif
 !-- compressed domain, serialize non-void cells
-     call inputstr_compress
+    call inputstr_compress
 
 !-- READ DATA
 !-- read ion and level data
@@ -94,6 +97,7 @@
 !--
 !-- setup remaining modules
 !==========================
+
   call timestepmod_init
 
 !-- wlgrid (before grid setup)
@@ -103,6 +107,15 @@
 !-- setup spatial grid
   call gridmod_init(lmpi0,grp_ng,str_nc,str_lvoid,icell1,ncell)
   call grid_setup
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     MODIFICATION BY LSU
+  call hydromod_init
+  call hydro_setup
+  call grid_volume(grd_igeom,grd_isvelocity,tsp_t)
+
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- setup gas
   call gasmod_init(lmpi0,icell1,ncell,grp_ng)
   call gas_setup
@@ -147,9 +160,17 @@
      write(6,'(1x,a5,a9,1x,a5,a10,4(a7,1x),a7)') 'it','t[day]','itflx','e_err','nsrc','ncens','nflux','nflxbuf','usage'
   endif
 !
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     HYDRO LSU
+!  tsp_itrestart = max(1,tsp_itrestart)
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   do it=tsp_itrestart,tsp_nt
      t_timelin(1) = t_time() !timeline
 !-- allow negative and zero it for temperature initialization purposes
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     HYDRO LSU
+     it_gt_0 = it .gt. 0
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      tsp_it = max(it,1)
 
 !-- Update tsp_t etc
@@ -163,6 +184,11 @@
      call grid_update(tsp_t)
      call gas_update(it)
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     MODIFICATION BY LSU
+     if( in_radiation_on ) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- source energy: gamma and material
      call sourceenergy
 
@@ -237,6 +263,7 @@
      call temperature_update
      call reduce_gastemp !MPI  !for output
 
+
 !-- output
      if(lmpi0) then
 !-- total energy startup values and energy conservation
@@ -261,6 +288,11 @@
         endif
      endif !impi
 
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     MODIFICATION BY LSU
+     endif !( in_radiation_on ) then
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+
 !-- write timestep timing to file
      call timing_cycle(impi,it<=0)
      call counters_cycle(impi,it<=0)
diff -r d244a10db46e timestepmod.f90
--- a/timestepmod.f90	Mon Feb 20 16:32:09 2017 -0700
+++ b/timestepmod.f90	Thu Feb 15 15:27:16 2018 -0600
@@ -13,6 +13,10 @@
   real*8,allocatable :: tsp_tpreset(:)  !store preset time steps from input.tsp_time
   real*8 :: tsp_tcenter,tsp_tfirst,tsp_tlast
   real*8 :: tsp_dt,tsp_dtinv
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     HYDRO LSU
+  logical :: it_gt_0
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
   private read_timestep_preset
 
@@ -40,6 +44,10 @@
     allocate(tsp_tarr(tsp_nt+1))
     tsp_tarr(1) = tsp_t
 !!}}}
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+!     HYDRO LSU
+    it_gt_0 = .false.
+!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   end subroutine timestepmod_init
 
 
diff -r d244a10db46e transportmod.f
--- a/transportmod.f	Mon Feb 20 16:32:09 2017 -0700
+++ b/transportmod.f	Thu Feb 15 15:27:16 2018 -0600
@@ -202,11 +202,21 @@
 c
 c-- abstract interfaces
       abstract interface
-      subroutine direction2lab_(x0,y0,z0,mu0,om0)!{{{
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+c     Old code
+c      subroutine direction2lab_(x0,y0,z0,mu0,om0)!{{{
 c     -------------------------------------------
-      real*8,intent(in) :: x0,y0,z0
+c      real*8,intent(in) :: x0,y0,z0
+c      real*8,intent(inout) :: mu0,om0
+c      end subroutine direction2lab_
+c     New code
+      subroutine direction2lab_(vx0,vy0,vz0,mu0,om0)!{{{
+c     -------------------------------------------
+      real*8,intent(in) :: vx0,vy0,vz0
       real*8,intent(inout) :: mu0,om0
       end subroutine direction2lab_
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 c
       pure subroutine advection_(pretrans,ptcl,ptcl2)
 c     -----------------------------------------------
@@ -322,44 +332,134 @@
 c
 c
 c
-      subroutine direction2lab1(x0,y0,z0,mu0,om0)
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+c     LSU MODIFICATION
+c      subroutine direction2lab1(x0,y0,z0,mu0,om0)
+c     -------------------------------------------
+c      implicit none
+c      real*8,intent(in) :: x0,y0,z0
+c      real*8,intent(inout) :: mu0,om0
+c      real*8 :: cmffact,mu,dummy
+c
+c      dummy = y0
+c      dummy = z0
+c      dummy = om0
+c
+c      cmffact = 1d0+mu0*x0*cinv
+c      mu = (mu0+x0*cinv)/cmffact
+c      mu = min(mu,1d0)
+c      mu = max(mu,-1d0)
+c      mu0 = mu
+c      end subroutine direction2lab1
+c
+c
+c      subroutine direction2lab2(x0,y0,z0,mu0,om0)
+c     -------------------------------------------
+c      implicit none
+c      real*8,intent(in) :: x0,y0,z0
+c      real*8,intent(inout) :: mu0,om0
+c      real*8 :: cmffact,gm,mu,om,dummy
+c
+c      dummy = z0
+c
+c      cmffact = 1d0+(mu0*y0+sqrt(1d0-mu0**2)*cos(om0)*x0)*cinv
+c      gm = 1d0/sqrt(1d0-(x0**2+y0**2)*cinv**2)
+!-- om
+c      om = atan2(sqrt(1d0-mu0**2)*sin(om0),
+c     &     sqrt(1d0-mu0**2)*cos(om0)+(gm*x0*cinv) *
+c     &     (1d0+gm*(cmffact-1d0)/(gm+1d0)))
+c      if(om<0d0) om=om+pc_pi2
+!-- mu
+c      mu = (mu0+(gm*y0*cinv)*(1d0+gm*(cmffact-1d0)/(1d0+gm))) /
+c     &     (gm*cmffact)
+c      mu = min(mu,1d0)
+c      mu = max(mu,-1d0)
+c      mu0 = mu
+c      om0 = om
+c      end subroutine direction2lab2
+c
+c
+c      subroutine direction2lab3(x0,y0,z0,mu0,om0)
+c     -------------------------------------------
+c      implicit none
+c      real*8,intent(in) :: x0,y0,z0
+c      real*8,intent(inout) :: mu0,om0
+c      real*8 :: cmffact,mu1,mu2,mu,om
+c
+c      mu2 = sqrt(1d0-mu0**2)
+c      mu1 = mu2*cos(om0)
+c      mu2 = mu2*sin(om0)
+c      cmffact = 1d0+(mu0*z0+mu1*x0+mu2*y0)*cinv
+!-- mu
+c      mu = (mu0+z0*cinv)/cmffact
+!-- om
+c      om = atan2(mu2+y0*cinv,mu1+x0*cinv)
+c      if(om<0d0) om = om+pc_pi2
+!-- in bounds
+c      mu = min(mu,1d0)
+c      mu = max(mu,-1d0)
+c      mu0 = mu
+c      om0 = om
+c      end subroutine direction2lab3
+
+      pure subroutine direction2lab11(vx0,mu0)
 c     -------------------------------------------
       implicit none
-      real*8,intent(in) :: x0,y0,z0
-      real*8,intent(inout) :: mu0,om0
-      real*8 :: cmffact,mu,dummy
+      real*8,intent(in) :: vx0
+      real*8,intent(inout) :: mu0
+      real*8 :: cmffact,mu
 c
-      dummy = y0
-      dummy = z0
-      dummy = om0
-c
-      cmffact = 1d0+mu0*x0*cinv
-      mu = (mu0+x0*cinv)/cmffact
+      cmffact = 1d0+(mu0*vx0)*cinv
+      mu = (mu0+vx0*cinv)/cmffact
       mu = min(mu,1d0)
       mu = max(mu,-1d0)
       mu0 = mu
+      end subroutine direction2lab11
+c
+      pure subroutine direction2lab1(vx0,vy0,vz0,mu0,om0)
+c     -------------------------------------------
+      use gridmod
+      implicit none
+      real*8,intent(in) :: vx0,vy0,vz0
+      real*8,intent(inout) :: mu0,om0
+      real*8 :: cmffact,mu,sin0,om
+c
+c
+      if( grd_igeom .eq. 11 ) then
+        call direction2lab11(vx0,mu0)
+        om0 = 0d0
+      else
+        sin0 = sqrt(1d0 - mu0*mu0)
+        cmffact = 1d0+(mu0*vx0+sin0*(cos(om0)*vy0+sin(om0)*vz0))*cinv
+        mu = (mu0+vx0*cinv)/cmffact
+        mu = min(mu,1d0)
+        mu = max(mu,-1d0)
+        om = atan2(sin0*sin(om0)+vz0*cinv,
+     &     sin0*cos(om0)+vy0*cinv)
+        if(om<0d0) om=om+pc_pi2
+        mu0 = mu
+        om0 = om
+      endif
+
       end subroutine direction2lab1
 c
 c
-      subroutine direction2lab2(x0,y0,z0,mu0,om0)
+      pure subroutine direction2lab2(vx0,vy0,vz0,mu0,om0)
 c     -------------------------------------------
       implicit none
-      real*8,intent(in) :: x0,y0,z0
+      real*8,intent(in) :: vx0,vy0,vz0
       real*8,intent(inout) :: mu0,om0
-      real*8 :: cmffact,gm,mu,om,dummy
+      real*8 :: cmffact,mu,om
+      real*8 :: sin0
 c
-      dummy = z0
-c
-      cmffact = 1d0+(mu0*y0+sqrt(1d0-mu0**2)*cos(om0)*x0)*cinv
-      gm = 1d0/sqrt(1d0-(x0**2+y0**2)*cinv**2)
-!-- om
-      om = atan2(sqrt(1d0-mu0**2)*sin(om0),
-     &     sqrt(1d0-mu0**2)*cos(om0)+(gm*x0*cinv) *
-     &     (1d0+gm*(cmffact-1d0)/(gm+1d0)))
+      sin0 = sqrt(1d0-mu0*mu0)
+      cmffact = 1d0+(mu0*vy0+sin0*(cos(om0)*vx0+sin(om0)*vz0))*cinv
+! -- om
+      om = atan2(sin0*sin(om0)+vz0*cinv,
+     &     sin0*cos(om0)+vx0*cinv)
       if(om<0d0) om=om+pc_pi2
 !-- mu
-      mu = (mu0+(gm*y0*cinv)*(1d0+gm*(cmffact-1d0)/(1d0+gm))) /
-     &     (gm*cmffact)
+      mu = (mu0+vy0*cinv) / cmffact
       mu = min(mu,1d0)
       mu = max(mu,-1d0)
       mu0 = mu
@@ -367,21 +467,21 @@
       end subroutine direction2lab2
 c
 c
-      subroutine direction2lab3(x0,y0,z0,mu0,om0)
+      pure subroutine direction2lab3(vx0,vy0,vz0,mu0,om0)
 c     -------------------------------------------
       implicit none
-      real*8,intent(in) :: x0,y0,z0
+      real*8,intent(in) :: vx0,vy0,vz0
       real*8,intent(inout) :: mu0,om0
       real*8 :: cmffact,mu1,mu2,mu,om
 c
       mu2 = sqrt(1d0-mu0**2)
       mu1 = mu2*cos(om0)
       mu2 = mu2*sin(om0)
-      cmffact = 1d0+(mu0*z0+mu1*x0+mu2*y0)*cinv
+      cmffact = 1d0+(mu0*vz0+mu1*vx0+mu2*vy0)*cinv
 !-- mu
-      mu = (mu0+z0*cinv)/cmffact
+      mu = (mu0+vz0*cinv)/cmffact
 !-- om
-      om = atan2(mu2+y0*cinv,mu1+x0*cinv)
+      om = atan2(mu2+vy0*cinv,mu1+vx0*cinv)
       if(om<0d0) om = om+pc_pi2
 !-- in bounds
       mu = min(mu,1d0)
